#!/bin/bash

# version: beta v2.8.31, patches 2013.03.01.

# PDroid created by svyat. Official PDroid thread is 
# http://forum.xda-developers.com/showthread.php?t=1357056

# The Auto-Patcher created by pastime1971 and mateorod
# Thread and support for the Auto-Patcher can be found at
# http://forum.xda-developers.com/showthread.php?p=27589651#post27589651

# ChangeLog
# 2012.05.00. (v0.1) 
# ...........
# 2012.05.12. (v0.2)   allows user to specify a different version of patches
# 2012.05.13. (v0.3.0) force "patch -N", remove temp upon failure, generate log output
# 2012.05.13. (v0.3.1) revised the generation of updater-script (SGS2)
# 2012.05.15.          added AOSP patches
# 2012.05.15.          added crespo-aosp patches; device-specific patching if patch exists
# 2012.05.15.          remove restore.zip upon failure
# 2012.05.15. (v0.4.1) added CM7 (GB) patches
# 2012.05.18. (v0.4.2) added checking for tool commands
# 2012.05.21. (v0.4.3) apply device-specific patches only when it is specified
# 2012.05.26.           added task title to log
# 2012.05.31. (v0.4.4) CM9 patches updated, crespo-aosp added
# 2012.06.04. (v0.4.5) added checking tools and rom, added aroma installer support
#                       add patch outputs reroute
# 2012.06.15.          CM9 patches updated
# 2012.06.16. (v0.4.6) AOKP patches updated, patch versions restructured
# 2012.06.17. (v0.5.0) patcher script reorganized, removed build.prop
# 2012.06.17. (v0.6.0) auto patcher script for pdroid and v6 patches
# 2012.06.19. (v0.6.1) add patches for CM7.2 Final
# 2012.06.20. (v0.6.2) updated CM 7.2 patches
# 2012.06.23. (v0.6.3) fix symlinks
# 2012.06.26. (v0.6.4) added 0618 patches for cm7 nightlies; removed 0619 cm7.2 final
# 2012.06.27. (v0.6.5) added new CM9 patches (20120626)
# 2012.06.27. (v0.6.6) added CM7 nightly patches (20120625) (finally!)
# 2012.07.02. (v0.7.0) Redid AOSP/AOKP; add Windows support (using Cygwin). Thanks kobik77!
# 2012.07.06. (v0.7.1) updated CM9 patches (20120706)
# 2012.07.08. (v0.7.2) updated AOKP (20120707) and CM9 (20120708) pdroid patches
# 2012.07.11. (v1.0.0) reworked script works on Linux, Mac OSX, and Windows (on Cygwin); 
# 		        added new ICS/JellyBean support for the new V6-Supercharger
# 2012.07.18. (v1.0.1) new CM7/CM9 Pdroid patches (20120718)
# 2012.07.23. (v1.0.2) updated CM9 patches (20120723)
# 2012.07.23. (v1.0.3) updated CM9 patches (20120724)
# 2012.08.06. (v1.5.0) updated smali/baksmali binaries to 1.33
# 2012.08.06. 	       Added Pdroid/V6supercharger support for CM10 Jellybean!
# 2012.08.06.	       Improved PDroid stability and efficiency (Thanks CollegeDev)
# 2012.08.06. (v1.6.0) added aokp-jb patches for pdroid/v6supercharger, script update
# 2012.08.17. (v1.9.5) Added support for pdroid_addon, by CollegeDev.
#		        Added insecure boot.img mod
#		        Added support for aosp-jb (This needs testing, and may not be
#		              a wide patch due to large variation between AOSP roms. 
#                      		          -Please report all experiences!
#		        Updated all v6supercharger patches w/new edits to ProcessList
#                       Major script overhaul in preparation for additional mods!
# 2012.08.20. (v1.9.6) Conditional support for Official cm10 and aokp-jb builds
# 2012.08.23. (v1.9.7) Final/confirmed pdroid support for Official CM10 and AOKP-JB
# 2012.09.04  (v1.9.8) Bundled cygwin-compatible tools (original was corrupt).
#		       For Cygwin, replaced h2b function with simple bash math
#			  conversion (req'd for compat w/ Cygwin tools).
# 2012.08.26. (v2.0.0) Added .apk patching
#		       Added 3G Dongle support for Nexus 7
#                      TabletUI support for Nexus 7 (maybe more)
#		       Google Voice support for Nexus 7
#				mods are 3gdongle, tabletUI, voice, or nexus7suite (for all)
#		        Added provisional file copy menu to widen patching base
# 2012.09.11. (v2.0.1) Cygwin support fixes
# 2012.09.11. (v2.0.2) Bugfix for 3gdongle (all)
# 2012.09.16. (v2.1.0) Significant restructuring of core operations; added edit text file
#		        fix for "method-cap" errors in pdroid.
# 2012.09.20. (v2.1.1) Fix for Phone FC's; OSX support finalized; ContentResolver resolved
# 2012.09.28. (v2.1.2) Hotfix for failed pdroid patching. Logging improvements.
# 2012.10.07. (v2.1.5) Final pdroid support for CM7.2 Official Releases
#			Added aosp-mod patches for pdroid patching of AOSP kangs
#			Switched to Chainfire's (f)aapt for speed/space reasons
# 2012.10.13. (v2.1.6) New PDroid patches for aokp-jb and cm10 4.1.2
#		        Revert (f)aapt- temporary due to reported issues
# 2012.10.15. (v2.17) New (again) CM10 pdroid patches.
#                     Move files to be copied into $p/$R/$B
#                       -This required a bunch of file moving-report broken symlinks. 
#                     Some error check on the old RIL delete functions (thanks bundrik)
# 2012.10.16. (v2.1.7.5) Fix FC on phone with CM10 pdroid patches
# 2012.10.19. (v2.1.9) Testing CM10 support for PDroid Extension by CollegeDev.
# 2012.10.22. (v2.2.0) aosp/aokp and cm10 support for pdroid extension by CollegeDev
#                       MAJOR reworking of patches and improved query. only 4 mod types:
#                       cm, aokp, aosp, and pa. See our OP for details.
# 2012.10.26. (v2.3.0) Final (LTS) version. Stable for now until upstream breaks any patches
#                      Thanks to KicknGuitar for the OSX testing!
# 2012.11.01. (v2.3.1) Fix for pdroid RIL deletion for older roms
#                       Better Build query logic and help messages
# 2012.11.02. (v2.3.5) Add Evervolv support for all mods- Thanks to new maintainer poncik!
#                       Fix method cap for pdroid/pd2.0 for AOKP and kangs
# 2012.11.06. (v2.4.0) Update pd2.0 patches to latest pd2.0 release- all except Evervolv
#                       add GsmService to smali.txt; improve rom probe
# 2012.11.08. (v2.4.2) Add Evervolv support for pd2.0; Device-specific scripts
#                       Will display error if using a mod on an inapplicable rom
# 2012.11.09. (v2.4.5) Error catch for random method issues, fix pd2.0 Evervolv and aosp-jb
# 2012.11.17. (v2.4.6) Fix pdroid for CM7. FINALLY!.
# 2012.11.17. (v2.4.7) Internal debugging improvements
# 2013.01.13. (v2.5.0) Added 'openpdroid' mod --Open-Source Pdroid framework
#                       BIG Improvements to help and error-catch. Try ./auto_patcher -h
# 2013.01.15. (v2.5.1) OpenPDroid support for Evervolv and ParanoidAndroid, hotfix for Mms 
# 2013.01.15. (v2.5.2) Fix for cygwin temp files (kobik), provisional telephony files added
# 2013.01.16. (v2.5.3) SlimRom support. Rearrange structure for ApG.
# 2013.01.23. (v2.5.4) Fix small bugs related to rearrange
# 2013.01.25. (v2.5.7) 4.2 TabletUI support [cm,aokp,aosp,Evervolv]
# 2013.01.28. (v2.5.8) Fix for ICS PDroid; small fixes/expansions
# 2013.02.01. (v2.6.0) OpenPdroid 1.0.1 patches (cm, aokp, aosp, evervolv and slimrom. no pa.
#                       Fixed TabletUI for Cm10.1- aosp to come. Removed most old patches.
# 2013.02.01. (v2.6.25) PA OpenPDroid 1.0.1 patches; AOSP TabletUI. removed opd all 1.0.0
# 2013.02.09. (v2.7.0) Add new AOKP, CM9, CM10,CM10.1 and PA (3.0) patches for OPD
# 2013.02.09. (v2.7.5) Add new AOKP, AOSP, CM10.1 and PA (3.0) patches for OPD (Andr. 4.2.2)
# 2013.02.17. (v2.7.9) 4.2.2 opd 4 evervolv; v6supercharger,3gdongle and all but tabletUI.
# 2013.02.20. (v2.8.0) New CM10.1 opd patches. Each BID can have own provisionals now.
# 2013.02.23. (v2.8.2) SlimRom 4.2.2 support (from karamelos), APK recompile safety net.
# 2013.03.01. (v2.8.3) PAC (.aosp-pac) 4.2.2 support (from AussieLambChops), apktool 1.5.2
# 2013.03.02. (v2.8.31)Remove Settings.apk.patch from CM tabletUI patches


# SHELL PROGRAMMING NOTES:
# [ -s FILE ] 
# [[ -n STRING ]] or [[ -z STRING ]] 

VERSION="v2.8.31"
CURRENT_ANDROID="4.2.2"

# pass variables to children
set -a

printusage_help () {
     PID="openpdroid,3gdongle" # default example
     brief_help
}

brief_help () {
     echo "    usage:     ./auto_patcher <ROM> <MODS> <ROMTYPE>"
     echo "    example:   ./auto_patcher CM10.zip $PID cm"
     echo ""
     echo "Use ./auto_patcher -h for the help menu"
     echo ""
     cleanup
     exit
}

usage_help () {
     PID=mods
     mods_display
     echo "Multiple MODS can be combined by separating them with a comma and NO SPACES!!!"
     echo ""
     echo "    usage:     ./auto_patcher <ROM> <MODS> <ROMTYPE>"
     echo ""
     echo "    example:   ./auto_patcher CM10.zip openpdroid,3gdongle cm"
     echo ""
     usage_more_help
}

usage_more_help () {
     echo "* press 'q' available patches or CTRL-c to quit the help menu *"
}

display_help () {
     cd patches
     echo ""
     echo "AVAILABLE PATCHES"
     echo ""
     echo "*******************************************************************"
     echo "Note: There are ONLY 4 ROMTYPES: [pa, cm, aokp, and aosp]."
     echo ""
     find -H *  \( -name aokp -o -name cm -o -name aosp -o -name pa -o -name all -o -name generic \) -prune | column -c 85 | more -d -7
     echo ""
     echo "!!! Do not put Android Version number on command line !!!!"
     echo "*****************************************************************"
     echo "Specific auto_patcher script options"
     echo "    ./auto_patcher -h mods      Lists mods"
     echo "                   -h <MODNAME> Specific <MOD> info"
     echo "                   -h advanced  Advanced usage+lists all available patch dates"
     echo ""
     cleanup
     exit
}

romtype_help () {
     # From rom_error (bad romtype) and date_error (patch date w/o specifying romtype)
     echo ""
     echo "!!!There are only four supported ROMTYPES: 1) cm  2) aokp  3) aosp  4) pa"
     echo ""
     echo "Find out which of the above ROMTYPES your rom is based on and try again!"
     echo "**********************************************"
     echo ""
     cleanup
     brief_help
}

advanced_help () {
     echo ""
     echo "The Auto-Patcher Advanced Usage"
     echo "*********************************"
     echo ""
     echo "For those of you determined to try everything..."
     echo ""
     echo "You can also try adding a patch date as a final argument."
     echo ""
     echo "      ./auto_patcher <ROM> <MOD> <ROMTYPE> <DATE>"
     echo ""
     echo "Please note: There are only four ROMTYPES: {pa, aokp, aosp and cm}"
     echo "      -The various appellations after that are for internal use only!"
     echo ""
     echo "The Auto-Patcher has a pretty great rom probe, specifying the date is"
     echo " deprecated...you don't need to, we promise."
     echo ""
}

cleanup () {
	[[ -n $ROOT ]] && \rm -rf "$ROOT"/tmp*
}

garbage () {
	unset GARBAGE
	GARBAGE=($(find $@ -name "*.orig")) && rm -rf ${GARBAGE[@]} && echo "GARBAGE= ${GARBAGE[@]}" >> "$LOG"
	GARBAGE=($(find $@ -name "*.rej"))  && rm -rf ${GARBAGE[@]} && echo "GARBAGE= ${GARBAGE[@]}" >> "$LOG"
}


print_error () {
     # General purpose error. Used for errors in main, as opposed to probe or set-up.
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     brief_help
}

smali_error () {
     # Smali binary error. Problem often goes away on second run.
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     if [[ `grep 'method index is too large' "$LOG"` != "" ]]; then
          printtask "!!! Problem with method cap !!!"
          printtask "... attempting fix ..."
          . patches/.common/framework.jar.sh 2>&1 > ${JAR}.log
          printtask "... rebuild framework.jar ..."
          java -Xmx512M -jar smali.jar -a $API tmp/${FILE}.out/smali -o tmp/${FILE}.out/classes.dex >> "$LOG" 2>> "$LOG"
          [ -f tmp/${FILE}.out/classes.dex ] || print_error "Could not resolve method cap issue- please submit log"
     else
          printtask "!!! This error is generally due to an unknown bug in the smali binary!"
          echo "In our experience, it goes away if you run the patcher a second time."
          echo " Please run the Auto-Patcher with the same command once again."
          echo ""
          echo "If after the third attempt the same thing happens,"
          echo " please upload your logfile to our support thread!"
          echo ""
          cleanup
          exit
     fi
}

mismatch_error () {
     # Function that exposes attempts to apply a mod to an upsupported Android version
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     cleanup
     brief_help
}

date_error () {
     # Remind users to include a romtype if they are going to specify a patch date
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     echo "Please put a ROMTYPE before the patch date and run again!!"
     romtype_help
}

rom_error () {
     # For when an unsupported romtype is manually entered on the command-line
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     romtype_help
}

conflict_error () {
     # For conflicting packages
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     cleanup
     PID=mods
     mods_info
}

misspatch_error () {
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!! error: $@ "
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     printtask "!! The Auto-Patcher could not find its patches and/or tools!"
     echo ""
     echo "* Did you run ./batch.sh first?"
     echo ""
     echo "The patch_patches.tgz and patch_tools.tgz need to be in this directory,"
     echo "  one way or another..."
     echo ""
     cleanup
     brief_help
}

misstools_error () {
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!! error: $@ "
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "Your set-up is missing a dependency."
     echo "We require JDK, tar, patch and cpio."
     echo ""
     echo ""
     echo "Each distro is different"
     echo "but ensure you have them all installed and try again."
     echo ""
     cleanup
     brief_help
}

printtask () {
	echo "" >> "$LOG"
	echo -e $@ | tee -a "$LOG"
}

copyfailed () {
	echo ""
	printtask "File for which patching failed:"
	printtask "---------------------------------------------"
	echo ""
	printtask "${FAIL##*/}"
	echo ""
	echo "---------------------------------------------"
	echo ""
	echo "We can try to add a premade copy of those files."
	echo "This sometimes works."
	echo ""
	printtask "You only need to report this if running the program gives you problems!!!"
	echo ""
	echo ""
	askconsent && return 0 || return 1
}

askconsent () {
     sleep 1
     echo -n "Do you want to proceed ? (YES/no) "
     read PROCEED
     echo "askconsent final = ${PROCEED}: for $FAIL" >> "$LOG"
     case $PROCEED in
          [Yy] | [Yy][Ee][Ss])
               return 0;       # successful:
               echo "*** You (or ApG) have elected to use a prepatched copy of $FAIL ***" >> "$LOG"
               ;;
          *)
               return 1;	# error
               echo "*** You have declined to insert $FAIL by not answering 'yes' at the prompt. ***" >> "$LOG"
               ;;
     esac
}

replace_updater () {

# Function for devices that use SDcard installs. Also to be tested for CM7
#  since CM7 seems to use an updater-script that wipes EMMC. Testing

     \rm $UPDATER_LOC/$UPDS
     \cp patches/.common/$UPDATER_LOC/$UPDS $UPDATER_LOC
     echo "run_program(\"/sbin/busybox\", \"umount\", \"/system\");" >> UPDATE.txt
     cat UPDATE.txt >> $UPDATER_LOC/$UPDS
     echo ""
     echo "New updater-script being used:" >> "$LOG"
     echo "-----------------------------" >> "$LOG"
     cat $UPDATER_LOC/$UPDS >> "$LOG"
}

abspath () {
     case `uname -s` in
     CYGWIN*)
          echo $(cygpath -ua "$1") | sed 's:/$::g'
          ;;
     Darwin)
          #[[ $(echo $1 | awk '/^\//') == $1 ]] && echo "$1" || echo "$PWD/$1"
          [[ ${1:0:1} == "/" ]] && echo "$1" || echo "$PWD/$1"
          ;;
     Linux)
          echo $(readlink -f "$1")
          ;;
     *)
          if [[ ${1:0:1} == "/" ]]; then
               echo "$1"
          elif [[ ${1:0:2} == "./" ]]; then
               echo "$PWD/${1:2}"
          else
               echo "$PWD/$1"
          fi
          ;;
     esac
}

mods_display () {
     echo ""
     echo "The Auto-Patcher $VERSION"
     echo "*******************************"
     echo ""
     echo "The available mods are"
     echo "****************************************************"
     echo "*  pdroid   openpdroid  voice   v6supercharger     *"
     echo "*  voice    insecure    secure  external_internal  *"
     echo "*  tabletUI 3gdongle    pd2.0                      *"
     echo "****************************************************"
     echo ""
     echo "To find out more about any mod, simply enter:"
     echo "     ./auto_patcher -h <MODNAME>"
     echo ""
     cleanup
}

mods_info () {
     # Defaults
     DEPENDENCY="None"
     DEV="Unknown"
     CEILING=$CURRENT_ANDROID
     ROM_CONFLICTS="None"
     case $PID in
        mods)
             mods_display
             exit
             ;;
        auto*)
             echo ""
             echo "**************************************"
             echo "The Auto-Patcher ate a kitten once..."
             echo "**************************************"
             echo ""
             printusage_help
             ;;
        advanced)
             cd patches/
             (advanced_help && find -H * -name 201*) | more -d
             echo ""
             brief_help
             ;;
        voice)
             FLOOR=4.0.0
             DESC="Use on wifi-only tablets to have the software register as 'voice-enabled'. Allows VOIP like Google Voice to function."
             DESC="bongostl's setup method here: http://forum.xda-developers.com/showthread.php?t=1823701"
             DEV="bongostl"

             ;;
        v6 | v6supercharger)
             FLOOR=4.0.0
             CEILING=4.2.2
             DESC="A memory-management tool. It requires smali edits for Android roms 4.0+. The Auto-Patcher applies all 50+ edits recommended by the dev."
             DEV="Zeppelinrox"
             DEPENDENCY="The V6 Supercharger Script. Get it at http://forum.xda-developers.com/showthread.php?t=991276/"
             PID="v6supercharger" # allows shorthand 'v6' to find patches.
               ;;
        pdroid)
             FLOOR=2.3.7
             CEILING=4.1.2
             DESC="Security Software that safely manages permissions w/o causing FC's. No longer under development. Try the open-source expansion of this program, PDroid Manager. (It's the 'openpdroid' mod within the Auto-Patcher)."
             DEV="Svyat"
             DEPENDENCY="The Pdroid app. You can get it at http://forum.xda-developers.com/showthread.php?t=1923576"
             ;;
        pd2.0)
             FLOOR=4.1.2
             CEILING=4.1.2
             DESC="An expansion of the PDroid application/framework."
             DEV="CollegeDev"
             DEPENDENCY="The free PDroid2.0 app available at http://forum.xda-developers.com/showthread.php?t=1923576"
             ;;
        openpdroid)
             FLOOR=4.1.2
             CEILING=4.2.2
             DESC="A fork of the open-source PDroid and Pdroid2.0 framework."
             DEV="FFU5y/wbedard/mateorod/Community"
             DEPENDENCY="The PDroidManager app freely available from Google Play or http://forum.xda-developers.com/showthread.php?t=1994860"
             ;;
        opendroid)
             echo ""
             echo "No mod named 'opendroid'. You probably mean 'openpdroid'. Try again."
             PID="mods"
             mods_info
             ;;
        external_internal)
             FLOOR=2.3.3
             DESC="Swap internal and external storage."
             ;;
        insecure)
             FLOOR=2.3.3
             DESC="Make any boot.img insecure and allow remount as well as adb push/pull of system files. True root."
             ;;
        secure)
             FLOOR=2.3.3
             DESC="Make any boot.img secure."
             ;;
        3gdongle)
             FLOOR=4.1.0
             CEILING=4.2.2
             DESC="Allows 3gdongles to work on wifi tablets w/o 3rd party applications."
             DEV="trevd"
             DEPENDENCY="None, but read the troubleshooting guide at http://forum.xda-developers.com/showthread.php?t=1798631"
             ;;
        tabletUI)
             FLOOR=4.1.0
             CEILING=4.2.1
             ROM_CONFLICTS=(pa .aosp-slim)
             DESC="Changes the user interface of Phones and Phablets to the popular Tablet UI."
             DEV="barmullio"
             ;;
        *)
             FLOOR=?????
             CEILING=?????
             DESC="??? Unknown modtype ??? Check your spelling or the mod list!"
             #DESC1="./auto_patcher -h mods"
        esac
     # strip decimals from android version (i.e. 2.3.7 becomes 237) so we can do math
     NVID=${VID//[.]/}
     COMPATF=${FLOOR//[.]/}
     COMPATC=${CEILING//[.]/}
}

apk_check () {
     if [ -f patches/$P/$A/$R/$B/$FILE ]; then
          echo "... Patching $APK failed, but we will copy over a prepatched file ..."
          \cp -av patches/$P/$A/$R/$B/$FILE $FILE >> "$LOG"
     else
          print_error "failed patching $APK!!!"
     fi
}

compat_check () {
     for P in ${PID[@]}; do
          mods_info
          if [[ "$NVID" -lt "$COMPATF" ]]; then
               mismatch_error "Your Android $VID rom is too old! The minimum for $P is \n !!! Android $FLOOR!"
          fi
          if [[ "$NVID" -gt "$COMPATC" ]]; then
               mismatch_error "Sorry, $P has not been made available for Android $VID yet!"
          fi
     done
}

rom_compat_check () {
     for P in ${PID[@]}; do
     N=${#ROM_CONFLICTS[@]}
          for ((i=0; i < $N; i++)); do
               if [[ $RID == ${ROM_CONFLICTS[$i]} ]]; then
                    rom_compat_error
               fi
          done
     done
}

rom_compat_error () {
     print_error "$RID is incompatible with $PID!!!"
}

extpath () {
     case `uname -s` in
     CYGWIN*)
          echo $(cygpath -da "$1")
          ;;
     *)
          echo $(abspath "$1")
          ;;
     esac
}

#contains () { for e in "${@:2}"; do [[ "$e" = "$1" ]] && return 0; done; return 1; }

parse () { echo "${1%%_*}"; }

getbuildprop () {
     if [ -f system/build.prop ]; then
          result=(`grep $1 system/build.prop | tr -d '\r' | tr '=' ' '`)
          echo "${result[1]}"
     else
          echo ""
     fi
}


aosp_mod_check() {
     jar -xvf "$ROMX" system/framework/framework2.jar >> $LOG
     if [ -s system/framework/framework2.jar ]; then
          ever_check
     else
          AOSP=aosp
     fi
     echo $AOSP
}

ever_check() {
     MID=$(getbuildprop ro.build.romversion)
     if [[ $MID == "Evervolv"* ]]; then
          AOSP=".aosp-ever"
     else
          MID=$(getbuildprop ro.build.display.id)
          if [[ "$MID" == "ev"* ]]; then
               AOSP=".aosp-ever"
          else
               slim_check
          fi
     fi
     echo $AOSP
}

slim_check() {
     SLMID=$(getbuildprop ro.modversion)
     SLMMID=$(getbuildprop updateme.name)
     if [[ "$SLMMID" == "Slim"* ]] || [[ $SLMMID == "slim"* ]]; then
          AOSP=".aosp-slim"
     elif [[ "$SLMID" == "Slim"* ]] || [[ $SLMID == "slim"* ]]; then
          AOSP=".aosp-slim"
     else
          if [[ "$ANDR" == "4.1" ]]; then
               AOSP=.aosp-mod
          else
               AOSP="aosp"
          fi
     fi
}

pa_check() {
     CMID=$(getbuildprop ro.modversion)
     PAID=$(getbuildprop ro.pa.version)
     MID=$(getbuildprop ro.build.display.id)
     [[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
     DID=$(getbuildprop ro.product.device)
     [[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)
          if [[ -n $PAID ]]; then
              RID=pa
          else
               case $CMID in
                    [Pp][Aa]*)
                          RID=pa;
                          ;;
                     *)
                          RID=cm;
                          ;;
               esac
          fi
}

romtype_set () {
     case $RID in
          cm)
               ROMTYPE="cm"
               ;;
          aokp*)
               ROMTYPE="aokp"
               ;;
          pa)
               ROMTYPE="pa"
               ;;
          *)
               ROMTYPE="aosp"
               ;;
     esac
}

proberom () {
     VID=$(getbuildprop ro.build.version.release)
     if [ ${#VID} -lt 4 ]; then # in case of non-standard versioning in build.prop (defy!)
          ANDR=$VID
     else
          ANDR="${VID%.*}" # Cut to 1 significant digit to cover specific range or release.
     fi
     if [ "$ANDR" == "2.3" ]; then
          FLAVR=gingerbread
          API=10
          RID=cm;
     elif [ "$ANDR" == "4.0" ]; then
          FLAVR=ics
          API=15
          MID=$(getbuildprop ro.rommanager.developerid)
          [[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.modversion))
          DID=$(getbuildprop ro.product.device)
          [[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

          case "$MID" in
               pa|cm9|cm|cyanogenmod*)
                    RID=cm;
                         ;;
                    aokp|teamkang)
                         RID=aokp;
                         ;;
                    aosp*)
                         RID=aosp;
                         ;;
                    *)
                         echo "!!! $MID is not supported yet, trying aosp !!!"
                         RID=aosp
                         ;;
          esac
     elif [ "$ANDR" == "4.1" ]; then
          FLAVR=jellybean
          API=16
          CMID=$(getbuildprop ro.cm.version)
               if [[ -n $CMID ]]; then
                    pa_check
               else
		          MID=$(getbuildprop ro.build.display.id)
		          [[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
		          DID=$(getbuildprop ro.product.device)
		          [[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)
		          case "$MID" in
		              cm10|cm*|cyanogenmod*)
			              RID=cm;
			              ;;
		              aokp*|teamkang)
			              RID=aokp;
			              ;;
                        pa*)
                              echo "MID izzzzz $MID!"
                              if [[ "$MID" == "pac"* ]] || [[ "$MID" == "PAC"* ]]; then
                                   echo "bummbubble"
                                   RID=".aosp-pac"
                              else
                                   RID=pa;
                              fi
                             ;;
                        ev*)
                             RID=".aosp-ever";
                             ;;
                        *)
			              RID=`aosp_mod_check`;
			              ;;
		          esac
               fi
     elif [ "$ANDR" == "4.2" ]; then
          FLAVR=jellybean
          API=17
          CMID=$(getbuildprop ro.cm.version)
          MID=$(getbuildprop ro.build.display.id)
          [[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
          DID=$(getbuildprop ro.product.device)
          [[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

               case "$MID" in
                    cm10|cm*|cyanogenmod*)
                         RID=cm;
                         ;;
                    aokp*|teamkang)
                         RID=aokp;
                         ;;
                    pa*)
                         if [[ "$MID" == "pac"* ]] || [[ "$MID" == "PAC"* ]]; then
                              echo "bummbubble"
                              RID=".aosp-pac"
                         else
                              RID=pa;
                         fi
                         ;;
                    ev*|Ever*)
                         RID=".aosp-ever";
                         ;;
                    *)
	                    RID=`ever_check`;
			          ;;
               esac
     else
          print_error "unknown ROM version $VID"
     fi
     romtype_set
     echo "... result of ROM check: version= $VID rom= $ROMTYPE ..."
}


# Advanced build date query
# This should set the patch date automatically.

build_query() {
UTC=$(getbuildprop ro.build.date.utc)

# Difference in how OS X and Linux/Cygwin handles 'date' utility
case `uname -s` in
        [Dd]arwin)
             BDID=`date -r $UTC +%Y%m%d`
             echo "#### Darwin Build Query used ####" >> "$LOG"
             ;;
        *)
             BDID=`date -d "1970-01-01 UTC $UTC seconds" +"%Y%m%d"`
             echo "#### Standard Build Query ####" >> "$LOG"
             ;;
esac

# If patch date is specified on CLI, use that patch date
if [ $# -gt 3 ]; then
	BID=${4//,/ };
     BDID=$BID
else
     case $ANDR in
          2.3)
               # CM7 roms do not have UTC time stamp- so no build query.
               BID=latest;
               echo "*** CM7 roms default to latest patches. If using an older rom ***"
               echo "*** specify patch date on command line. Use -h to see available patches ***"
               ;;
          *)
               for P in ${PID[@]}; do
                    [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
                    [ -d patches/$P/$A/$RID ] && R=$RID || R=generic
                    [ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
                    PAR=patches/$P/$A/$R
                    PARB=patches/$P/$A/$R/$B
                    DATES=`ls patches/$P/$A/$R/ | grep '201*'`
             # Intialize variable - High so as to determine lowest in first loop.
                    BID=20201231
                         # find earliest available patch date
                         for i in $DATES; do
                              if [[ $i -lt $BID ]]; then
                                   BID=$i
                              fi
                         done
       # Check if earliest patches are from before build date. Else use earliest

                        # If rom is newer than earliest patch set, find best match
                         if [[ $(($BID-$BDID)) -lt 0 ]]; then
                              for g in $DATES; do
                                   # use any patch that matches $UTC
                                   if [[ $(($BDID-$g)) -eq 0 ]]; then
                                        BID=$g
                                        break
                                   # Set highest $BID w/o going over $UTC
                                   elif [[ $(($BDID-$g)) -gt 0 ]] && [[ $g -gt $BID ]]; then
                                        BID=$g
                                   fi
                              done
                         fi
                         echo "... $PID patch date has been set to: $BID ..."
                         B=$BID
                         break
               done
               ;;
     esac
     # Error Catch. If build query failed, it was breaking down through missing symlinks
     [[ $BID == "20201231" ]] && BID=latest && echo "Build Query Failed!! Default to latest!" >> "$LOG"
fi
}
        
proberil () {
	RIL=$(getbuildprop ro.telephony.ril_class)
	[[ -n $RIL ]] && printtask "... result of ROM check: RIL= $RIL"
}

rominfo () {
echo "# VER= $VERSION" >> "$LOG"
echo "# OS=  $OSTYPE ${BIT}bit" >> "$LOG"
echo "# VID= $VID" >> "$LOG"
echo "# PID= ${PID[@]}" >> "$LOG"
echo "# MID= $MID" >> "$LOG"
echo "# RID= $RID" >> "$LOG"
echo "# ANDR= $ANDR" >> "$LOG"
echo "# BDID= $BDID" >> "$LOG"
echo "# DID= $DID" >> "$LOG"
echo "# BID= $BID" >> "$LOG"
echo "Patches are $PID/$ANDR/$RID/$BID" >> "$LOG"

}

if [[ $1 == -h ]]; then
     if [ $# -gt 1 ]; then
          PID=$2
          mods_info
          echo ""
          echo "The Auto-Patcher $VERSION by Mateorod and Pastime1971"
          echo "*************************************************"
          echo ""
          echo "Mod Name:    $PID"
          echo ""
          echo "    $DESC"
          if [[ -z $DESC1 ]]; then # test to see is there is a second DESC line
               echo "$DESC1"
          fi
          if [[ $((DESC2)) -gt 0 ]]; then
               echo "$DESC2"
          fi
          echo ""
          echo "Developer: $DEV"
          echo "Dependancies: $DEPENDENCY"
          echo ""
          echo "Works on ROMs from Android $FLOOR -> $CEILING"
          echo
          brief_help
          exit
     fi
fi

[[ $# -lt 1 || -z $1 ]] && PID="mods" && mods_info
[[ $1 == "-h" ]] && usage_help | less && display_help

echo ""
echo "The Auto-Patcher $VERSION"
echo ""
# by pastime1971 and mateorod

ROOT=$(abspath `dirname "$0"`)
TOOL="$ROOT/patch_tools.tgz"
PTCH="$ROOT/patch_patches.tgz"
cleanup
# set temporaray directory
DATE=`date +%Y%m%d%H%M%S`
TEMP=$ROOT/tmp$DATE
TMP=$ROOT/tmp$DATE
TMPDIR=$ROOT/tmp$DATE
mkdir "$TEMP"
ROM=$(abspath "$1")
ROMX=$(extpath "$1")

if [[ $OSTYPE == "cygwin" ]]; then
	EXE=".exe"
	PGFORM="0x"
fi

LOG=$(abspath ./log$DATE.txt)
#echo $ROOT $TOOL $ROM $TEMP "$LOG"
echo "ROOT= $ROOT" >> "$LOG"
echo "TOOL= $TOOL" >> "$LOG"
echo "ROM=  $ROM" >> "$LOG"
echo "ROMX= $ROMX" >> "$LOG"

\rm -f $RESTORE.zip $UPDATE.zip

CHK=$(getconf LONG_BIT) 
if [[ $CHK = "64" ]]; then
	BIT=64
else [[ $BIT = "32" ]];
	BIT=32
fi

printtask "### verify tools ###"
which patch >> "$LOG" || misstools_error "Missing \"patch\" utility."
which tar >> "$LOG" || misstools_error "Missing \"tar\" utility"
which jar >> "$LOG" || misstools_error "Missing \"Java Development Kit\" (JDK)"
which java >> "$LOG" || misstools_error "Missing \"Java Development Kit\" (JDK)"
which cpio >> "$LOG" || misstools_error "Missing \"cpio\" utility"
[ -f "$TOOL" ] || misspatch_error "patch_tool.tgz is missing"
[ -f "$PTCH" ] || misspatch_error "patch_patches.tgz is missing"
printtask "### verify ROM ###"
[ -f "$ROM" ] || print_error "Cannot find $1!! Make sure you have the location and name right"
echo "### running $0 $@" >> "$LOG"
cd "$TEMP"

PATH="$TEMP:$PATH"
export PATH
echo "PATH= $PATH" >> "$LOG"

printtask "### unzip patch tools ###"
tar xzf "$TOOL" > /dev/null || print_error "failed extracting tools !!!"

# Get OS specific tools
     case `uname -s` in
           CYGWIN*)
               \mv cygwin/aapt.exe .
               \mv cygwin/*.exe boot/
               \rm -rf cygwin # why? If you want to we can keep/add it to mac/linux, though.
               ;;
          [Dd]arwin)
               \mv mac/aapt .
               ;;
          [Ll]inux)
               \mv linux/aapt .
               ;;
          *)
               \mv linux/aapt .
               ;;
     esac
# Ensure aapt permissions - possibly to one day be expanded to all tools in a function.
chmod a+x aapt$EXE
		
printtask "### unzip patch patches ###"
tar xzf "$PTCH" > /dev/null || print_error "failed extracting patches !!!"

# we need build.prop for both RIL probing and ROM probing
jar -xvf "$ROMX" system/build.prop 2>> "$LOG" || print_error "failed extracting build.prop from $ROMX !!!"

# rom + ril type
proberil
printtask "### probe rom type ###"
proberom

# rom type
if [ $# -gt 1 ]; then
        PIT=$2
        if [[ "$PIT" = "-h" ]]; then
              display_help
        fi
fi
if [ $# -gt 2 ]; then
	RID=$3        
     case "$RID" in
		cm10|cm*|cyanogenmod*)
			;;
		aokp*|teamkang)
			RID=aokp;
			;;
          pa*)
               RID=pa;
               ;;
          .aosp-ever)
               RID=".aosp-ever";
               ;;
          .aosp-slim)
               RID=".aosp-slim"
               ;;
          aosp*)
	          case "ANDR" in
                    4.1)
                         RID=`aosp_mod_check`;
                         ;;
                    *)
                         RID=`ever_check`
                         ;;
               esac
               ;;
          201*)
               date_error "You must specify ROMTYPE if designating a patch date!!"
               ;;
          *)
               rom_error "$RID is not a valid ROMTYPE!!"
               ;;
	esac
     romtype_set
	echo "... Using $ROMTYPE patches ..."
else
	echo "... Using results of ROM check ..."	
fi

# patch type
if [ $# -gt 1 ]; then
	PIL=${2//,/ } # If more than one mod, make string separated by spaces
else
	PIL="openpdroid"
     echo "No mods selected. Defaulting to openpdroid, since that's what you probably want..."
fi

# Ensure only 1 Pdroid mod at a time; PDroid first, so provisional use
#  does not overwrite other mods...

PID=(${PIL// / }) # turn string of requested mods into array
COPYPID=("${PID[@]}") # working copy to iterate over
MODS_NUMBER=${#COPYPID[@]} # number of elements (mods)

if [[ $MODS_NUMBER > 1 ]]; then # cause if only one mod, no point
INDEX=0 # 'pd2.0' didn't work with unset; regex barred multiple 'pdroid'
     for p in ${COPYPID[@]}; do
          if [ "$p" = "pdroid" ] || [ "$p" = "pd2.0" ] ||[ "$p" = "openpdroid" ]; then
               SPID[0]=$p               #set pdroid first
               unset COPYPID["$INDEX"]
               break
          else
               INDEX=$((INDEX + 1))  # if !pdroid, set as 1, 2...
          fi
     done
     for p in ${COPYPID[@]}; do
          if [ "$p" = "pdroid" ] || [ $p = "pd2.0" ] ||[ $p = "openpdroid" ]; then
               conflict_error "Those mods conflict! Only one pdroid mod at a time!"
          else
               i=${#SPID[@]}
               SPID[i]=$p
               i+=1
          fi
     done
else
     SPID=${COPYPID[@]}
fi
for P in ${PIL[@]}; do
	[[ ${PID[@]} =~ $P ]] || PID=(${PID[@]} $P)
done

# Check if selected mods are available for rom's Android version.
compat_check

# Make sure mod and rom don't conflict (e.g. pa and tabletUI)
if [[ $ROM_CONFLICTS != "None" ]]; then
     rom_compat_check
fi

# Build date
if [ $# -gt 3 ]; then # if a date is specified on command line...

     # Set date to match argument and ensure that patches with that date exist
     BID=$4
     [ -d patches/$P/$ANDR/$RID/$BID ] || print_error  "No $P patches for $RID on $BID!! Try the help menu!!"

     # Run build_query- this overrides the above but gets useful info
     build_query
     # Reset patch date to argument
	BID=$4
     echo "... $PID patch date set manually to: $BID ..."
else
        build_query # if no date specified, use one from build_query
fi

# echo ROM info
rominfo

if [[ ( "$PID" == "-h" || "$RID" == "-h" || "$BID" == "-h" ) ]]; then
     #Although this placement may be perfect for romfilter. although it throws the scheme...
     display_help
fi
#Begin cycle

for P in ${PID[@]}; do
     [ -d patches/$P ] || print_error "$P is not available"
     [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
     [ -d patches/$P/$A/$RID ] && R=$RID || R=generic
     [ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest

     unset FILES
     [ -f patches/$P/files.txt ] && FILES=$(cat patches/$P/files.txt)
     [ -f patches/$P/$A/files.txt ] && FILES=$(cat patches/$P/$A/files.txt)
     [ -f patches/$P/$A/$R/files.txt ] && FILES=$(cat patches/$P/$A/$R/files.txt)
     [ -f patches/$P/$A/$R/$B/files.txt ] && FILES=$(cat patches/$P/$A/$R/$B/files.txt)
     for FILE in ${FILES[@]}; do
          case "$FILE" in
               +system/*)
                    [[ ${CID[@]} =~ ${FILE:1} ]] && print_error "${FILE:1} is already being copied" || CID=(${CID[@]} ${FILE:1})
                    ;;
               -system/*)
                    [[ ${EID[@]} =~ ${FILE:1} ]] || EID=(${EID[@]} ${FILE:1})
                    ;;
               system/*.jar)
                    [[ ${JID[@]} =~ $FILE ]] || JID=(${JID[@]} $FILE)
                    echo "set_perm(0, 0, 0644, \"/$FILE\");" >> UPDATE.txt
                    ;;
               ~system/*apk) # apks to decompile with smali binaries instead of apktool
                    [[ ${JID[@]} =~ ${FILE:1} ]] || JID=(${JID[@]} ${FILE:1})
                    FORMATTED_FILE=${FILE:1}
                    echo "set_perm(0, 0, 0644, \"/$FORMATTED_FILE\");" >> UPDATE.txt
                    ;;
               system/*.apk)
                    [[ ${AID[@]} =~ $FILE ]] || AID=(${AID[@]} $FILE)
                    echo "set_perm(0, 0, 0644, \"/$FILE\");" >> UPDATE.txt
                    ;;
               *.img)
                    [[ ${IID[@]} =~ $FILE ]] || IID=(${IID[@]} $FILE)
                    ;;
               system/*)
                    [[ ${TID[@]} =~ $FILE ]] || TID=(${TID[@]} $FILE)
                    ;;
          esac
     done
done
echo "### DELETE FILES= ${EID[@]}" >> "$LOG"
echo "### COPY FILES= ${CID[@]}" >> "$LOG"
echo "### JAR FILES= ${JID[@]}" >> "$LOG"
echo "### APK FILES= ${AID[@]}" >> "$LOG"
echo "### IMG FILES= ${IID[@]}" >> "$LOG"
echo "### TXT FILES= ${TID[@]}" >> "$LOG"

# extract system files
printtask "### unzip rom ###"
jar -xvf "$ROMX" ${JID[@]} ${AID[@]} ${IID[@]} ${TID[@]} 2>> "$LOG" || print_error "failed extracting ${JID[@]} ${AID[@]} ${IID[@]} from $ROMX !!!"


# Update/Restore.zip scripts and prep 
printtask "### create updater script ###"
UPDATER_LOC=META-INF/com/google/android
UPDS=updater-script
UPDATE="update-$ROMTYPE-$DID-$BDID-${PIL// /-}"
RESTORE="restore-$ROMTYPE-$DID-$BDID"

jar -xvf "$ROMX" $UPDATER_LOC/$UPDS $UPDATER_LOC/update-binary
jar -xvf "$ROMX" $UPDATER_LOC/update-binary-installer 1> /dev/null 2> /dev/null

     # Determine Installer- Aroma or ClockworkMod
if [ -f $UPDATER_LOC/update-binary-installer ]; then
     printtask "... using Aroma installer ..."
     \mv $UPDATER_LOC/update-binary-installer $UPDATER_LOC/update-binary
else
     printtask "... using Clockworkmod installer ..."
fi

     # Create updater scripts
cat patches/.common/updater-message.txt >> $UPDS
cat $UPDATER_LOC/$UPDS | grep ^mount | grep "/system" | head -n 1 >> $UPDS
[ -s $UPDS ] || echo "run_program(\"/sbin/busybox\", \"mount\", \"/system\");" >> $UPDS
     # restore the original
for FILE in ${EID[@]}; do
     jar -xvf "$ROMX" $FILE 2> /dev/null || printtask "!!! warning $FILE cannot be restored !!!"
done
     # replace with the original or delete it
for FILE in ${CID[@]}; do
     jar -xvf "$ROMX" $FILE 2> /dev/null || echo "delete(\"/$FILE\");" >> $UPDS
done
echo "package_extract_dir(\"system\", \"/system\");" >> $UPDS
     # permission management for files that need specific perms
cat $UPDATER_LOC/$UPDS | grep set_perm | grep "/system" >> $UPDS
for P in ${PID[@]}; do
     if [ -s patches/$P/$A/set_perm.txt ]; then
          echo "...setting permissions..."
          cat patches/$P/$A/set_perm.txt >> $UPDS
     fi
done
cat $UPDATER_LOC/$UPDS | grep ^unmount | grep "/system" | head -n 1 >> $UPDS
[[ ${IID[@]} =~ boot.img ]] && cat $UPDATER_LOC/$UPDS | grep "boot.img" >> $UPDS
echo "ui_print(\"                                        .\");" >> $UPDS
echo "ui_print(\"                                            .\");" >> $UPDS
echo "ui_print(\"                                                done!\");" >> $UPDS
cat $UPDS > $UPDATER_LOC/$UPDS
echo "# generated $UPDS" >> "$LOG"
cat $UPDS >> "$LOG"

printtask "### create restore.zip ###"
jar -cvf tmp.zip ${JID[@]} ${AID[@]} ${IID[@]} META-INF > /dev/null 2>> "$LOG"
java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip signed.zip 2>> "$LOG"
\mv signed.zip $RESTORE.zip
\rm -f tmp.zip


# Begin patching process

     # decompile system files
printtask "### decompile system files ###"
for FILE in ${JID[@]}; do
     JAR=${FILE##*/}
     printtask "... decompile $JAR ..."
     java -jar baksmali.jar -b -a $API -o tmp/${FILE}.out/smali ${FILE} >> "$LOG" 2>> "$LOG"
     if [ $FILE == "system/framework/framework.jar" ]; then
          printtask "... extract preloaded-classes ..."
          jar -xvf ${FILE} preloaded-classes >> "$LOG" 2>> "$LOG"
          \mv preloaded-classes tmp/${FILE}.out/
     fi
done

     # install framework-files for APK...
if [ ${#AID[@]} -gt 0 ]; then
     jar -xvf "$ROMX" system/framework/framework-res.apk >> "$LOG"
     printtask "... installing framework files ..."
     java -jar apktool.jar if system/framework/framework-res.apk
   # Decompile APKs
     for FILE in ${AID[@]}; do
          APK=${FILE##*/}
          if [ -f $FILE ]; then
               printtask "... decompile $APK ..."
               java -jar apktool.jar d -f $FILE tmp/$FILE.out
          fi
     done
fi

     # Unpack image files {boot.img only so far...}
for FILE in ${IID[@]}; do
     printtask "### unpacking $FILE ###"
     case "$FILE" in
          boot.img)
               if [ -f boot.img ]; then
                    cd boot
                    ./unpackbootimg$EXE -i ../boot.img >> "$LOG" 2>> "$LOG"
                    mkdir ramdisk
                    cd ramdisk
                    gzip -dc ../boot.img-ramdisk.gz | cpio -i >> "$LOG" 2>> "$LOG"
                    cd ../../ 
               else
                    print_error "A mod needs to patch boot.img! This rom does not contains boot.img."
               fi
               ;;
          *)
               print_error "cannot process $FILE"
               ;;
     esac
done

	# apply system modification

for P in ${PID[@]}; do
     [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
     [ -d patches/$P/$A/$RID ] && R=$RID || R=generic
     [ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
     PAR=patches/$P/$A/$R
     PARB=patches/$P/$A/$R/$B

     unset FILES COPY DELS JARS APKS IMGS TXTS
     [ -f patches/$P/files.txt ] && FILES=$(cat patches/$P/files.txt)
     [ -f patches/$P/$A/files.txt ] && FILES=$(cat patches/$P/$A/files.txt)
     [ -f patches/$P/$A/$R/files.txt ] && FILES=$(cat patches/$P/$A/$R/files.txt)
     [ -f patches/$P/$A/$R/$B/files.txt ] && FILES=$(cat patches/$P/$A/$R/$B/files.txt)
     for FILE in ${FILES[@]}; do
          case $FILE in
               +system/*)
                    COPY=(${COPY[@]} ${FILE:1})
                    ;;
               -system/*)
                    DELS=(${DELS[@]} ${FILE:1})
                    ;;
               system/*.jar)
                    JARS=(${JARS[@]} $FILE)
                    ;;
               ~system/*)
                    JARS=(${JARS[@]} ${FILE:1})
                    ;;
               system/*.apk)
                    APKS=(${APKS[@]} $FILE)
                    ;;
               *.img)
                    IMGS=(${IMGS[@]} $FILE)
                    ;;
               system/*)
                    TXTS=(${TXTS[@]} $FILE)
                    ;;
          esac
     done

     [[ -n ${COPY[@]} ]] && echo "### copy patch $P/$A/$ROMTYPE/$B ###"
     echo "### copy patch $P/$A/$R/$B ###" >> "$LOG"
     for FILE in ${COPY[@]}; do
          printtask "... copying $FILE ..."
          DEST=${FILE%/*}
          mkdir -p ./$DEST
          if [ -e patches/$P/$A/$R/$B/$FILE ]; then
               [ -e $FILE ] && printtask "... overwriting $FILE from $P ..."
               \cp -av patches/$P/$A/$R/$B/$FILE ./$DEST >> "$LOG"
          else
               print_error "$FILE is missing in the patch. Please upload your logfile to the support thread!"
          fi
     done

     # unconditional smali copying- For particularly troublesome files
     [ -f patches/$P/smali.txt ] && SMALI=$(cat patches/$P/smali.txt)
     [ -f patches/$P/$A/smali.txt ] && SMALI=$(cat patches/$P/$A/smali.txt)
     [ -f patches/$P/$A/$R/smali.txt ] && SMALI=$(cat patches/$P/$A/$R/smali.txt)
     [ -f patches/$P/$A/$R/$B/smali.txt ] && SMALI=$(cat patches/$P/$A/$R/$B/smali.txt)
     MOVE=${SMALI##*/}
     for SMALI in ${SMALI[@]}; do
           if [ -f patches/$P/$A/$R/$B/$SMALI ]; then
                printtask "... overwriting $MOVE ..."
                \cp -a patches/$P/$ANDR/$R/$B/$SMALI tmp/$SMALI >> "$LOG"
# This lower area should be deprecated now...wait and see. Each BID has own link to provisionals now.
           elif [ -f patches/$P/$A/.provisionals/$SMALI ]; then
                printtask "... overwriting $MOVE ..."
                \cp -a patches/$P/$ANDR/.provisionals/$SMALI tmp/$SMALI >> "$LOG"
           fi
     done

     [[ -n ${DELS[@]} ]] && echo "### delete patch $P/$A/$ROMTYPE/$B ###"
     echo "### delete patch $P/$A/$R/$B ###" >> "$LOG"
     for FILE in ${DELS[@]}; do
          printtask "... deleting $FILE ..."
          \rm -rf ./$FILE
     done
     [[ -n ${JARS[@]} ]] && echo "### jar patch $P/$A/$ROMTYPE/$B ###"
     echo "### jar patch $P/$A/$R/$B ###" >> "$LOG"
     for FILE in ${JARS[@]}; do
          JAR=${FILE##*/}
          if [[ $FILE == *".jar" ]]; then # allows for *.apks to be decompiled by baksmali
               NAME=${JAR%.jar}
          else
               NAME=$JAR # TODO: Maybe rename this, since it now encompases apks at times
          fi
          printtask "... apply $NAME.patch ..."
          patch -Nls -p1 -d tmp/${FILE}.out < $PARB/${NAME}.patch 2>&1 > ${JAR}.log
          cat ${JAR}.log | tee -a "$LOG"
          case "$NAME" in
               framework)
                    # patch preloaded-classes only if a patch exists
                    if [ -f $PARB/preloaded.patch ]; then
                         printtask "... apply preloaded.patch ..."
                         patch -Nls -p1 -d tmp/${FILE}.out < $PARB/preloaded.patch 2>&1 > preloaded.log
                         cat preloaded.log | tee -a "$LOG"
                         [[ `grep FAILED preloaded.log` != "" ]] && print_error "failed preloaded.patch"
                    fi
                    ;;
               *)
                    echo -n ""	# do nothing else
                    ;;
          esac
          # substitute failed smali with provisional (a prepatched smali file)
          unset FAILS
          FAILS=(`grep FAILED ${JAR}.log | sed -e 's/.*smali\///' | sed -e 's/\.rej//'`)
          if [[ -n ${FAILS[@]} ]]; then
               printtask "!!! PATCHING FAILED FOR ${FAILS[@]} !!!"
               echo "### replace ${FAILS[@]} ###" > ${JAR}.log
               for FAIL in ${FAILS[@]}; do
                    PROVISIONAL="patches/$P/$ANDR/.provisionals/${FILE}.out/smali/${FAIL}"
                    echo "!!! patch error for $FAIL !!!" >> "$LOG"
                    #cat tmp/$FILE.out/smali/${FAIL}.rej >> "$LOG" # FOR DEBUGGING
                    [[ ${SID[@]} =~ $FAIL ]] && print_error "$FAIL was already replaced before"
                    [ -f "$PROVISIONAL" ] || print_error "failed $FAIL in $JAR cannot be remedied"
                    copyfailed
                    printtask "... replace $FAIL ..."
                    \rm -rf tmp/${FILE}.out/smali/${FAIL} tmp/${FILE}.out/smali/${FAIL}.orig tmp/${FILE}.out/smali/${FAIL}.rej
                    \cp -av  "$PROVISIONAL" tmp/${FILE}.out/smali/${FAIL} >> "$LOG" 
                    SID=(${SID[@]} $FAIL)
               done
          fi
          [[ `grep FAILED ${JAR}.log` != "" ]] &&  print_error "failed $NAME.patch"
          garbage tmp/${FILE}.out

     # run special $JAR.sh scripts if any JAR needs special attention 
          if [ -f patches/$P/$A/$R/$B/${JAR}.sh ]; then
               printtask "... apply $JAR.sh ..."
               . patches/$P/$A/$R/$B/${JAR}.sh 2>&1 > ${JAR}.log
               cat ${JAR}.log | tee -a "$LOG"
          fi
     done

     [[ -n ${APKS[@]} ]] && echo "### apk patch $P/$A/$ROMTYPE/$B ###"
     echo "### apk patch $P/$A/$R/$B ###" >> "$LOG"
     for FILE in ${APKS[@]}; do
          APK=${FILE##*/}
          if [ -d "tmp/${FILE}.out" ] ; then
               printtask "... apply $APK.patch ..."
               patch -Nls -p2 -d tmp/${FILE}.out < $PARB/${APK}.patch 2>&1 >> ${APK}.log
               cat ${APK}.log | tee -a "$LOG"
               [[ `grep FAILED ${APK}.log` != "" ]] && apk_check
               garbage tmp/${FILE}.out
          else
               echo "No $APK in your ROM. Not able to patch this file."
               echo "## No $APK in ROM ###" >> "$LOG"
          fi
     done
     [[ -n ${IMGS[@]} ]] && echo "### img patch $P/$A/$ROMTYPE/$B ###"
     echo "### img patch $P/$A/$R/$B ###" >> "$LOG"
     for FILE in ${IMGS[@]}; do
          IMG=${FILE##*/}
          printtask "... applying $IMG.patch ..."
          patch -Nls -p1 -d boot/ramdisk < $PARB/${IMG}.patch >> "$LOG" || print_error "failed patching $FILE"
     done

# Text Editing Functions --this can really do just about anything. Needs a working restore!
     [[ -n ${TXTS[@]} ]] && echo "### text patch $P/$A/$ROMTYPE/$B ###"
     echo "### text patch $P/$A/$R/$B ###" >> "$LOG"
     for FILE in ${TXTS[@]}; do
          TXT=${FILE##*/}
          if [[ -f $PARB/${TXT}.patch ]]; then
               printtask "... apply $TXT.patch ..."
               patch -Nls -p2 -d system/ < $PARB/${TXT}.patch 2>&1 > ${TXT}.log 
               #cat ${TXT}.log | tee -a "$LOG"
               [[ `grep FAILED ${TXT}.log` != "" ]] && print_error "failed $TXT.patch"
          fi
          if [[ -f $PAR/${TXT}.awk ]]; then
               printtask "... apply $TXT.awk ..."
               awk -f $PAR/${TXT}.awk $FILE > text || print_error "failed $TXT.awk"
               mv text $FILE
          fi
          if [[ -f $PAR/${TXT}.sed ]]; then
               printtask "... apply $TXT.sed ..."
               sed -f $PAR/${TXT}.sed $FILE > text || print_error "failed $TXT.sed"
               mv text $FILE
          fi
          if [[ -f $PAR/${TXT}.sh ]]; then
               printtask "... apply $TXT.sh ..."
               . $PAR/${TXT}.sh 2>&1 >> ${TXT}.log || print_error "failed $TXT.sh"
          fi
          garbage system/
     done
done

     # Device specific scripts- Placement is up-for-review
if [ -f patches/.devices/$DID/$DID.sh ]; then
     . patches/.devices/$DID/$DID.sh
fi

     # Replace updater-script for CM7- it formats system -Testing
if [ "$ANDR" == "gingerbread" ]; then
     replace_updater
fi

# Rebuilding system files

[[ -n ${JID[@]} ]] && printtask "### rebuild jar ###"
for FILE in ${JID[@]}; do
     JAR=${FILE##*/}
     printtask "... rebuild $JAR ..."
     java -Xmx512M -jar smali.jar -a $API tmp/${FILE}.out/smali -o tmp/${FILE}.out/classes.dex >> "$LOG" 2>> "$LOG"
     [ -f tmp/${FILE}.out/classes.dex ] || smali_error "failed compiling $JAR !!!"
     jar -ufv ${FILE} -C tmp/${FILE}.out/ classes.dex >> "$LOG" 2>> "$LOG"
     if [ $FILE == "system/framework/framework.jar" ]; then
          jar -ufv ${FILE} -C tmp/${FILE}.out/ preloaded-classes >> "$LOG" 2>> "$LOG"
     fi
done

[[ -n ${AID[@]} ]] && printtask "### rebuild apk ###"
for FILE in ${AID[@]}; do
     APK=${FILE##*/}
     if [ -d tmp/${FILE}.out ]; then
          printtask "... rebuild $APK ..."
          java -jar apktool.jar b tmp/${FILE}.out >> "$LOG" 2>> "$LOG" || apk_check
          jar -uvf $FILE -C tmp/${FILE}.out/build/apk/ . > /dev/null 2>> "$LOG"
     fi
done

[[ -n ${IID[@]} ]] && printtask "### rebuild img ###"
for FILE in ${IID[@]}; do
     printtask "### rebuild $FILE ###"
     case $FILE in
          boot.img)
               # Rebuilding boot.img
               cd boot
               printtask "... rebuilding ramdisk ..."
               ./mkbootfs$EXE ./ramdisk | gzip > ramdisk-new.gz

               printtask "... composing boot.img ..."
               BASE=$(cat boot.img-base)
               # hex to decimal in cygwin prefixing "0x" w/ C arithmetic
               PGSIZE=$((${PGFORM}$(cat boot.img-pagesize)))
               CMDLINE=$(cat boot.img-cmdline)
               echo "cmdline = no_console_suspend=1 console=null $CMDLINE" >> "$LOG"
               echo "pagesize = $PGSIZE" >> "$LOG"
               echo "base = $BASE" >> "$LOG"
               printtask "... rebuilding boot.img ..."
               ./mkbootimg$EXE --kernel boot.img-zImage --ramdisk ramdisk-new.gz --cmdline "no_console_suspend=1 console=null $CMDLINE" --base "$BASE" --pagesize "$PGSIZE" -o ../boot.img || print_error "failed building boot.img"
               cd ..
               ;;
          *)
               print_error "cannot process $FILE"
               ;;
     esac
done

printtask "### create $UPDATE.zip ###"
jar -cfv tmp.zip ${IID[@]} ${JID[@]} ${AID[@]} ${CID[@]} ${TID[@]} META-INF >> "$LOG" 2>> "$LOG"
java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip $UPDATE.zip 2>> "$LOG"

\mv $RESTORE.zip $UPDATE.zip ..
echo "### finished ###"
echo "flash $UPDATE.zip to install the patched files"
echo "flash $RESTORE.zip to restore the original system"

     # add announcement- optional.
for P in ${PID[@]}; do
     [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
     [ -d patches/$P/$A/$RID ] && R=$RID || R=generic
     [ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
     if [ -f patches/$P/$A/$R/$B/README.txt ]; then
          cat patches/$P/$A/$R/$B/README.txt
     elif [ -f patches/$P/$A/$R/README.txt ]; then
          cat patches/$P/$A/$R/README.txt
     elif [ -f patches/$P/$A/README.txt ]; then
          cat patches/$P/$A/README.txt
     fi
done

cd ..
\rm -rf "$TEMP"
